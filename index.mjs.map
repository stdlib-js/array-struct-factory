{"version":3,"file":"index.mjs","sources":["../lib/from_array.js","../lib/main.js","../lib/from_iterator.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport getter from '@stdlib/array-base-getter';\nimport accessorGetter from '@stdlib/array-base-accessor-getter';\nimport Uint8Array from '@stdlib/array-uint8';\nimport { ndarray as gcopy } from '@stdlib/blas-base-gcopy';\n\n\n// MAIN //\n\n/**\n* Fills an output ArrayBuffer with array values.\n*\n* @private\n* @param {Function} Struct - struct constructor\n* @param {ArrayBuffer} buf - output data buffer\n* @param {Collection} arr - input array\n* @throws {TypeError} an input array must contain struct instances\n* @throws {TypeError} each element of an input array must be a struct instance having the expected layout\n* @returns {ArrayBuffer} output data buffer\n*/\nfunction fromArray( Struct, buf, arr ) {\n\tvar sbytes;\n\tvar bbytes;\n\tvar offset;\n\tvar layout;\n\tvar sview;\n\tvar opts;\n\tvar len;\n\tvar get;\n\tvar flg;\n\tvar nb;\n\tvar v;\n\tvar i;\n\n\topts = {\n\t\t'format': 'layout'\n\t};\n\n\tlen = arr.length;\n\tif ( arr.get && arr.set ) {\n\t\tget = accessorGetter( 'default' );\n\t} else {\n\t\tget = getter( 'default' );\n\t}\n\tlayout = Struct.layout;\n\tnb = Struct.byteLength;\n\n\t// FIXME: add optimization for when `buf` is a StructArray having the same layout, as can just copy bytes\n\n\tbbytes = new Uint8Array( buf );\n\toffset = 0;\n\tfor ( i = 0; i < len; i++ ) {\n\t\tv = get( arr, i );\n\t\ttry {\n\t\t\tsview = Struct.viewOf( v ); // note: this should throw if `v` is not a struct\n\t\t\tflg = true;\n\t\t} catch ( err ) { // eslint-disable-line no-unused-vars\n\t\t\ttry {\n\t\t\t\t// Attempt to convert the input value to a struct instance:\n\t\t\t\tv = new Struct( v ); // note: this should throw if `v` is not an object with valid fields\n\t\t\t} catch ( err ) { // eslint-disable-line no-unused-vars\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tsview = Struct.viewOf( v );\n\t\t\tflg = false;\n\t\t}\n\t\tif ( flg && v.toString( opts ) !== layout ) {\n\t\t\treturn null;\n\t\t}\n\t\tsbytes = new Uint8Array( sview.buffer, sview.byteOffset, sview.byteLength ); // eslint-disable-line max-len\n\t\tgcopy( nb, sbytes, 1, 0, bbytes, 1, offset );\n\t\toffset += nb;\n\t}\n\treturn buf;\n}\n\n\n// EXPORTS //\n\nexport default fromArray;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this, max-len, max-lines-per-function */\n\n'use strict';\n\n// MODULES //\n\nimport isStructConstructorLike from '@stdlib/assert-is-struct-constructor-like';\nimport { isPrimitive as isNonNegativeInteger } from '@stdlib/assert-is-nonnegative-integer';\nimport { isPrimitive as isInteger } from '@stdlib/assert-is-integer';\nimport isArrayBuffer from '@stdlib/assert-is-arraybuffer';\nimport isCollection from '@stdlib/assert-is-collection';\nimport isFunction from '@stdlib/assert-is-function';\nimport isObject from '@stdlib/assert-is-object';\nimport isPrototypeOf from '@stdlib/assert-is-prototype-of'; // eslint-disable-line stdlib/no-redeclare\nimport hasIteratorSymbolSupport from '@stdlib/assert-has-iterator-symbol-support';\nimport hasProp from '@stdlib/assert-has-property';\nimport contains from '@stdlib/array-base-assert-contains';\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport setReadOnlyAccessor from '@stdlib/utils-define-nonenumerable-read-only-accessor';\nimport ITERATOR_SYMBOL from '@stdlib/symbol-iterator';\nimport ArrayBuffer from '@stdlib/array-buffer';\nimport Uint8Array from '@stdlib/array-uint8';\nimport getter from '@stdlib/array-base-getter';\nimport accessorGetter from '@stdlib/array-base-accessor-getter';\nimport { ndarray as gcopy } from '@stdlib/blas-base-gcopy';\nimport structFactory from '@stdlib/dstructs-struct';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport fromArray from './from_array.js';\nimport fromIterator from './from_iterator.js';\n\n\n// VARIABLES //\n\nvar HAS_ITERATOR_SYMBOL = hasIteratorSymbolSupport();\nvar CTOR_NAME = 'StructArray';\n\n\n// MAIN //\n\n/**\n* Returns a constructor for creating arrays having a fixed-width composite data type.\n*\n* @param {(Function|Array<Object>)} arg - struct constructor or struct schema\n* @throws {TypeError} first argument must be either a struct constructor or struct schema\n* @returns {Function} constructor\n*\n* @example\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import structFactory from '@stdlib/dstructs-struct';\n*\n* var schema1 = [\n*     {\n*         'name': 're',\n*         'type': 'float64'\n*     },\n*     {\n*         'name': 'im',\n*         'type': 'float64'\n*     }\n* ];\n*\n* // Create a struct constructor for storing real and imaginary components:\n* var Components = structFactory( schema1 );\n*\n* var schema2 = [\n*     {\n*         'type': 'union',\n*         'fields': [\n*             {\n*                 'name': 'value',\n*                 'type': 'complex128'\n*             },\n*             {\n*                 'name': 'components',\n*                 'type': Components\n*             }\n*         ]\n*     }\n* ];\n*\n* // Create a struct constructor for storing a double-precision complex number:\n* var Complex128Struct = structFactory( schema2 );\n*\n* // Create an array constructor for storing complex numbers:\n* var Complex128Array = factory( Complex128Struct );\n*\n* // Create a new array:\n* var x = new Complex128Array( 10 );\n* // returns <StructArray>\n*\n* // Retrieve the first element:\n* var v1 = x.get( 0 );\n*\n* // Resolve the complex number stored within the first element:\n* var z1 = v1.value;\n* // returns <Complex128>[ 0.0, 0.0 ]\n*\n* // Resolve the individual real and imaginary components:\n* var z2 = v1.components;\n*\n* var re = z2.re;\n* // returns 0.0\n*\n* var im = z2.im;\n* // returns 0.0\n*\n* // Create a new complex number struct:\n* var z3 = new Complex128Struct({\n*     'value': new Complex128( 3.0, 5.0 )\n* });\n*\n* // Update the first element of the array:\n* x.set( z3, 0 );\n*\n* // As `v1` is a view on same memory as the first element, resolve the complex number stored within the element:\n* var z4 = v1.value;\n* // returns <Complex128>[ 3.0, 5.0 ]\n*/\nfunction factory( arg ) { // eslint-disable-line stdlib/jsdoc-require-throws-tags\n\tvar BYTES_PER_ELEMENT;\n\tvar LAYOUT;\n\tvar FIELDS;\n\tvar Struct;\n\n\t// FIXME: add option support for strict input object validation (e.g., throw whenever non-struct properties are included on an object passed to `set`)\n\n\tif ( isCollection( arg ) ) {\n\t\tStruct = structFactory( arg ); // NOTE: delegate to `structFactory` to perform input validation\n\t} else if ( isStructConstructorLike( arg ) ) {\n\t\tStruct = arg;\n\t} else {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be either a struct constructor or struct schema. Value: `%s`.', arg ) );\n\t}\n\tBYTES_PER_ELEMENT = Struct.byteLength;\n\tLAYOUT = Struct.layout; // TODO: consider whether to lazily materialize the struct layout, as this could potentially be a long string (hence increased memory consumption) depending on the complexity of the struct\n\tFIELDS = Struct.fields;\n\n\t/**\n\t* Constructor which returns an array having a fixed-width composite data type.\n\t*\n\t* @private\n\t* @constructor\n\t* @param {(NonNegativeInteger|Collection|ArrayBuffer|Iterable)} [arg] - length, typed array, array-like object, buffer, or an iterable\n\t* @param {NonNegativeInteger} [byteOffset=0] - byte offset\n\t* @param {NonNegativeInteger} [length] - view length\n\t* @throws {TypeError} must provide a valid first argument\n\t* @throws {TypeError} second argument must be a nonnegative integer\n\t* @throws {TypeError} third argument must be a nonnegative integer\n\t* @throws {RangeError} must provide sufficient memory to accommodate byte offset and view length requirements\n\t* @throws {RangeError} second argument must be a multiple of struct byte length\n\t* @throws {RangeError} second argument must not exceeds the ArrayBuffer bounds\n\t* @throws {TypeError} view length must be a positive multiple of struct byte length\n\t* @throws {TypeError} an input array must contain valid elements\n\t* @returns {StructArray} struct array instance\n\t*/\n\tfunction StructArray( arg, byteOffset, length ) {\n\t\tvar nargs;\n\t\tvar buf;\n\t\tvar len;\n\t\tvar tmp;\n\n\t\tnargs = arguments.length;\n\t\tif ( !( this instanceof StructArray) ) {\n\t\t\tif ( nargs === 0 ) {\n\t\t\t\treturn new StructArray();\n\t\t\t}\n\t\t\tif ( nargs === 1 ) {\n\t\t\t\treturn new StructArray( arg );\n\t\t\t}\n\t\t\tif ( nargs === 2 ) {\n\t\t\t\treturn new StructArray( arg, byteOffset );\n\t\t\t}\n\t\t\treturn new StructArray( arg, byteOffset, length );\n\t\t}\n\n\t\t// Case: new StructArray()\n\t\tif ( nargs === 0 ) {\n\t\t\tbuf = new ArrayBuffer( 0 );\n\t\t\tlen = 0;\n\t\t}\n\t\t// Case: new StructArray( arg )\n\t\telse if ( nargs === 1 ) {\n\t\t\t// Case: new StructArray( length )\n\t\t\tif ( isNonNegativeInteger( arg ) ) {\n\t\t\t\tbuf = new ArrayBuffer( arg*BYTES_PER_ELEMENT );\n\t\t\t\tlen = arg;\n\t\t\t}\n\t\t\t// Case: new StructArray( collection )\n\t\t\telse if ( isCollection( arg ) ) {\n\t\t\t\tlen = arg.length;\n\t\t\t\tbuf = fromArray( Struct, new ArrayBuffer( len*BYTES_PER_ELEMENT ), arg );\n\t\t\t\tif ( buf === null ) {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Each element of a provided input array must be a valid object or a struct instance having the same layout as elements in the desired output array.' ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Case: new StructArray( ArrayBuffer )\n\t\t\telse if ( isArrayBuffer( arg ) ) {\n\t\t\t\tbuf = arg;\n\t\t\t\tlen = buf.byteLength / BYTES_PER_ELEMENT;\n\t\t\t\tif ( !isInteger( len ) ) {\n\t\t\t\t\tthrow new RangeError( format( 'nullE9', BYTES_PER_ELEMENT, buf.byteLength ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Case: new StructArray( iterable )\n\t\t\telse if ( isObject( arg ) ) {\n\t\t\t\tif ( HAS_ITERATOR_SYMBOL === false ) {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Environment lacks Symbol.iterator support. First argument must be a length, ArrayBuffer, typed array, or array-like object. Value: `%s`.', arg ) );\n\t\t\t\t}\n\t\t\t\tif ( !isFunction( arg[ ITERATOR_SYMBOL ] ) ) {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. First argument must be a length, ArrayBuffer, typed array, array-like object, or an iterable. Value: `%s`.', arg ) );\n\t\t\t\t}\n\t\t\t\tbuf = arg[ ITERATOR_SYMBOL ]();\n\t\t\t\tif ( !isFunction( buf.next ) ) {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. First argument must be a length, ArrayBuffer, typed array, array-like object, or an iterable. Value: `%s`.', arg ) );\n\t\t\t\t}\n\t\t\t\ttmp = fromIterator( buf );\n\t\t\t\tlen = tmp.length;\n\t\t\t\tbuf = fromArray( Struct, new ArrayBuffer( len*BYTES_PER_ELEMENT ), tmp );\n\t\t\t\tif ( buf === null ) {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Each element of a provided input iterable must be either a valid object or a struct instance having the same layout as elements in the desired output array.' ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Case: new StructArray( ???? )\n\t\t\telse {\n\t\t\t\tthrow new TypeError( format( 'invalid argument. First argument must be a length, ArrayBuffer, typed array, array-like object, or an iterable. Value: `%s`.', arg ) );\n\t\t\t}\n\t\t}\n\t\t// Case: new StructArray( ArrayBuffer, byteOffset[, length] )\n\t\telse {\n\t\t\tbuf = arguments[ 0 ];\n\t\t\tif ( !isArrayBuffer( buf ) ) {\n\t\t\t\tthrow new TypeError( format( 'null2B', arg ) );\n\t\t\t}\n\t\t\tif ( !isNonNegativeInteger( byteOffset ) ) {\n\t\t\t\tthrow new TypeError( format( 'null3X', byteOffset ) );\n\t\t\t}\n\t\t\tif ( !isInteger( byteOffset/BYTES_PER_ELEMENT ) ) {\n\t\t\t\tthrow new RangeError( format( 'invalid argument. Second argument must be a multiple of %u. Value: `%u`.', BYTES_PER_ELEMENT, byteOffset ) );\n\t\t\t}\n\t\t\tif ( byteOffset >= buf.byteLength ) {\n\t\t\t\tthrow new RangeError( format( 'invalid argument. Second argument exceeds the bounds of the ArrayBuffer. Value: `%s`.', byteOffset ) );\n\t\t\t}\n\t\t\t// Case: new StructArray( ArrayBuffer, byteOffset )\n\t\t\tif ( nargs === 2 ) {\n\t\t\t\tlen = ( buf.byteLength - byteOffset ) / BYTES_PER_ELEMENT;\n\t\t\t\tif ( !isInteger( len ) ) {\n\t\t\t\t\tthrow new RangeError( format( 'invalid argument. ArrayBuffer view byte length must be a multiple of %u. View byte length: `%u`.', BYTES_PER_ELEMENT, buf.byteLength-byteOffset ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Case: new StructArray( ArrayBuffer, byteOffset, length )\n\t\t\telse {\n\t\t\t\tlen = length;\n\t\t\t\tif ( !isNonNegativeInteger( len ) ) {\n\t\t\t\t\tthrow new TypeError( format( 'null2m', len ) );\n\t\t\t\t}\n\t\t\t\tif ( (len*BYTES_PER_ELEMENT) > (buf.byteLength-byteOffset) ) {\n\t\t\t\t\tthrow new RangeError( format( 'null2G', len*BYTES_PER_ELEMENT ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetReadOnly( this, '_buffer', buf );\n\t\tsetReadOnly( this, '_byteOffset', byteOffset || 0 );\n\t\tsetReadOnly( this, '_byteLength', len*BYTES_PER_ELEMENT );\n\t\tsetReadOnly( this, '_length', len );\n\t\treturn this;\n\t}\n\n\t/**\n\t* Size (in bytes) of each array element.\n\t*\n\t* @private\n\t* @name BYTES_PER_ELEMENT\n\t* @memberof StructArray\n\t* @readonly\n\t* @type {PositiveInteger}\n\t*/\n\tsetReadOnly( StructArray, 'BYTES_PER_ELEMENT', BYTES_PER_ELEMENT );\n\n\t/**\n\t* Constructor name.\n\t*\n\t* @private\n\t* @name name\n\t* @memberof StructArray\n\t* @readonly\n\t* @type {string}\n\t*/\n\tsetReadOnly( StructArray, 'name', CTOR_NAME );\n\n\t/**\n\t* Element constructor.\n\t*\n\t* @private\n\t* @name struct\n\t* @memberof StructArray\n\t* @readonly\n\t* @type {Function}\n\t*/\n\tsetReadOnly( StructArray, 'struct', Struct );\n\n\t/**\n\t* Pointer to the underlying data buffer.\n\t*\n\t* @private\n\t* @name buffer\n\t* @memberof StructArray.prototype\n\t* @readonly\n\t* @type {ArrayBuffer}\n\t*/\n\tsetReadOnlyAccessor( StructArray.prototype, 'buffer', function get() {\n\t\treturn this._buffer;\n\t});\n\n\t/**\n\t* Size (in bytes) of the array.\n\t*\n\t* @private\n\t* @name byteLength\n\t* @memberof StructArray.prototype\n\t* @readonly\n\t* @type {NonNegativeInteger}\n\t*/\n\tsetReadOnlyAccessor( StructArray.prototype, 'byteLength', function get() {\n\t\treturn this._byteLength;\n\t});\n\n\t/**\n\t* Offset (in bytes) of the array from the start of its underlying `ArrayBuffer`.\n\t*\n\t* @private\n\t* @name byteOffset\n\t* @memberof StructArray.prototype\n\t* @readonly\n\t* @type {NonNegativeInteger}\n\t*/\n\tsetReadOnlyAccessor( StructArray.prototype, 'byteOffset', function get() {\n\t\treturn this._byteOffset;\n\t});\n\n\t/**\n\t* Size (in bytes) of each array element.\n\t*\n\t* @private\n\t* @name BYTES_PER_ELEMENT\n\t* @memberof StructArray.prototype\n\t* @readonly\n\t* @type {PositiveInteger}\n\t*/\n\tsetReadOnly( StructArray.prototype, 'BYTES_PER_ELEMENT', StructArray.BYTES_PER_ELEMENT );\n\n\t/**\n\t* Returns an array element.\n\t*\n\t* @private\n\t* @name get\n\t* @memberof StructArray.prototype\n\t* @type {Function}\n\t* @param {NonNegativeInteger} idx - element index\n\t* @throws {TypeError} `this` must be a struct array instance\n\t* @throws {TypeError} must provide a nonnegative integer\n\t* @returns {(*|void)} array element\n\t*/\n\tsetReadOnly( StructArray.prototype, 'get', function get( idx ) {\n\t\tif ( !isStructArray( this ) ) {\n\t\t\tthrow new TypeError( format( 'invalid invocation. `this` is not a %s.', CTOR_NAME ) );\n\t\t}\n\t\tif ( !isNonNegativeInteger( idx ) ) {\n\t\t\tthrow new TypeError( format( 'null2K', idx ) );\n\t\t}\n\t\tif ( idx >= this._length ) {\n\t\t\treturn;\n\t\t}\n\t\treturn new Struct( this._buffer, this._byteOffset+( idx*BYTES_PER_ELEMENT ), BYTES_PER_ELEMENT );\n\t});\n\n\t/**\n\t* Number of array elements.\n\t*\n\t* @private\n\t* @name length\n\t* @memberof StructArray.prototype\n\t* @readonly\n\t* @type {NonNegativeInteger}\n\t*/\n\tsetReadOnlyAccessor( StructArray.prototype, 'length', function get() {\n\t\treturn this._length;\n\t});\n\n\t/**\n\t* Sets an array element.\n\t*\n\t* ## Notes\n\t*\n\t* -   When provided a struct array, we must check whether the source array shares the same buffer as the target array and whether the underlying memory overlaps. In particular, we are concerned with the following scenario:\n\t*\n\t*     ```text\n\t*     buf:                ---------------------\n\t*     src: ---------------------\n\t*     ```\n\t*\n\t*     In the above, as we copy values from `src`, we will overwrite values in the `src` view, resulting in duplicated values copied into the end of `buf`, which is not intended. Hence, to avoid overwriting source values, we must **copy** source values to a temporary array.\n\t*\n\t*     In the other overlapping scenario,\n\t*\n\t*     ```text\n\t*     buf: ---------------------\n\t*     src:                ---------------------\n\t*     ```\n\t*\n\t*     by the time we begin copying into the overlapping region, we are copying from the end of `src`, a non-overlapping region, which means we don't run the risk of copying copied values, rather than the original `src` values, as intended.\n\t*\n\t* @private\n\t* @name set\n\t* @memberof StructArray.prototype\n\t* @type {Function}\n\t* @param {(Collection|StructArray|Struct|Object)} value - value(s)\n\t* @param {NonNegativeInteger} [i=0] - element index at which to start writing values\n\t* @throws {TypeError} `this` must be a struct array instance\n\t* @throws {TypeError} index argument must be a nonnegative integer\n\t* @throws {RangeError} index argument is out-of-bounds\n\t* @throws {RangeError} target array lacks sufficient storage to accommodate source values\n\t* @throws {TypeError} must provide a valid object or a struct instance having the same layout as elements in the target array\n\t* @returns {void}\n\t*/\n\tsetReadOnly( StructArray.prototype, 'set', function set( value ) {\n\t\tvar bbytes;\n\t\tvar sbytes;\n\t\tvar sbuf;\n\t\tvar opts;\n\t\tvar idx;\n\t\tvar buf;\n\t\tvar tmp;\n\t\tvar get;\n\t\tvar nb;\n\t\tvar N;\n\t\tvar s;\n\t\tvar f;\n\t\tvar i;\n\t\tvar j;\n\t\tif ( !isStructArray( this ) ) {\n\t\t\tthrow new TypeError( format( 'invalid invocation. `this` is not a %s.', CTOR_NAME ) );\n\t\t}\n\t\tbuf = this._buffer;\n\t\tif ( arguments.length > 1 ) {\n\t\t\tidx = arguments[ 1 ];\n\t\t\tif ( !isNonNegativeInteger( idx ) ) {\n\t\t\t\tthrow new TypeError( format( 'null2L', idx ) );\n\t\t\t}\n\t\t} else {\n\t\t\tidx = 0;\n\t\t}\n\t\topts = {\n\t\t\t'format': 'layout'\n\t\t};\n\t\tnb = Struct.byteLength;\n\n\t\tif ( isCollection( value ) && !contains( FIELDS, 'length' ) ) { // note: when one of the fields is 'length', we always assume that a provided value with a 'length' property is a struct and/or data object as there doesn't seem to be a surefire way to distinguish such an object from a regular array-like object (including accessor arrays)\n\t\t\tN = value.length;\n\t\t\tif ( idx+N > this._length ) {\n\t\t\t\tthrow new RangeError( format('null03') );\n\t\t\t}\n\t\t\tsbuf = value;\n\t\t\tif ( sbuf.get && sbuf.set ) {\n\t\t\t\tget = accessorGetter( 'default' );\n\t\t\t} else {\n\t\t\t\tget = getter( 'default' );\n\t\t\t}\n\t\t\t// Check for overlapping memory...\n\t\t\tj = this._byteOffset + (idx*BYTES_PER_ELEMENT);\n\t\t\tif (\n\t\t\t\tsbuf.buffer === buf &&\n\t\t\t\t(\n\t\t\t\t\tsbuf.byteOffset < j &&\n\t\t\t\t\tsbuf.byteOffset+sbuf.byteLength > j\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// FIXME: add optimization when `value` is a StructArray sharing the same buffer and having the same layout; in which case, we can simply copy `src` bytes to a temporary array and then copy those bytes into the target array, without needing to intermediate struct instance materialization\n\n\t\t\t\t// We need to copy source values...\n\t\t\t\ttmp = [];\n\t\t\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\t\t\ttmp.push( get( value, i ) );\n\t\t\t\t}\n\t\t\t\tsbuf = tmp;\n\t\t\t\tget = getter( 'default' );\n\t\t\t}\n\t\t\tfor ( i = 0; i < N; idx++, i++ ) {\n\t\t\t\tthis.set( get( sbuf, i ), idx ); // note: this likely isn't the most performant approach, but it avoids having to replicate branching logic for handling struct instances vs data objects\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( idx >= this._length ) {\n\t\t\tthrow new RangeError( format( 'null2M', idx ) );\n\t\t}\n\t\tif ( !isObject( value ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Must provide either a valid object or a struct instance. Value: `%s`.', value ) );\n\t\t}\n\t\t// Check for a struct instance having a matching layout...\n\t\tif ( value.toString( opts ) === LAYOUT ) {\n\t\t\t// Explicitly copy the bytes of the input struct instance to the corresponding array element...\n\t\t\tsbuf = Struct.viewOf( value );\n\t\t\tsbytes = new Uint8Array( sbuf.buffer, sbuf.byteOffset, nb );\n\t\t\tbbytes = new Uint8Array( buf, this._byteOffset+( idx*BYTES_PER_ELEMENT ), nb );\n\t\t\tgcopy( nb, sbytes, 1, 0, bbytes, 1, 0 );\n\t\t\treturn;\n\t\t}\n\t\t// Create a struct instance view for the target element:\n\t\ts = new Struct( buf, this._byteOffset+( idx*BYTES_PER_ELEMENT ), nb );\n\n\t\t// Assign field values from the input object (accounting for both own and inherited properties)...\n\t\tfor ( i = 0; i < FIELDS.length; i++ ) {\n\t\t\tf = FIELDS[ i ];\n\t\t\tif ( hasProp( value, f ) ) {\n\t\t\t\ts[ f ] = value[ f ];\n\t\t\t}\n\t\t}\n\t});\n\n\t/**\n\t* Element constructor.\n\t*\n\t* @private\n\t* @name struct\n\t* @memberof StructArray.prototype\n\t* @readonly\n\t* @type {Function}\n\t*/\n\tsetReadOnly( StructArray.prototype, 'struct', Struct );\n\n\treturn StructArray;\n\n\t/**\n\t* Returns a boolean indicating if a value is a struct array.\n\t*\n\t* @private\n\t* @param {*} value - value to test\n\t* @returns {boolean} boolean indicating if a value is a struct array\n\t*/\n\tfunction isStructArray( value ) {\n\t\treturn (\n\t\t\ttypeof value === 'object' &&\n\t\t\tvalue !== null &&\n\t\t\t(\n\t\t\t\tvalue.constructor.name === CTOR_NAME ||\n\t\t\t\tisPrototypeOf( value, StructArray.prototype )\n\t\t\t) &&\n\t\t\tvalue.BYTES_PER_ELEMENT === BYTES_PER_ELEMENT\n\t\t);\n\t}\n}\n\n\n// EXPORTS //\n\nexport default factory;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @returns {Array} output array\n*/\nfunction fromIterator( it ) {\n\tvar out;\n\tvar v;\n\n\tout = [];\n\twhile ( true ) {\n\t\tv = it.next();\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t\tout.push( v.value );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default fromIterator;\n"],"names":["fromArray","Struct","buf","arr","sbytes","bbytes","offset","layout","sview","opts","len","get","flg","nb","v","i","format","length","set","accessorGetter","getter","byteLength","Uint8Array","viewOf","err","toString","buffer","byteOffset","gcopy","HAS_ITERATOR_SYMBOL","hasIteratorSymbolSupport","CTOR_NAME","factory","arg","BYTES_PER_ELEMENT","LAYOUT","FIELDS","isCollection","structFactory","isStructConstructorLike","TypeError","StructArray","nargs","tmp","arguments","this","ArrayBuffer","isNonNegativeInteger","isArrayBuffer","isInteger","RangeError","isObject","isFunction","ITERATOR_SYMBOL","next","it","out","done","push","value","fromIterator","setReadOnly","fields","setReadOnlyAccessor","prototype","_buffer","_byteLength","_byteOffset","idx","isStructArray","_length","sbuf","N","s","f","j","contains","hasProp","constructor","name","isPrototypeOf"],"mappings":"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"}